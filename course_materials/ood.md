## OOD

объектно-ориентированный дизайн
Вопросы

1. ####Что такое SOLID?
В программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) 
для первых пяти принципов, названных Робертом Мартином в начале 2000-х, 
которые означали 5 основных принципов объектно-ориентированного программирования и проектирования.
При создании программных систем использование принципов SOLID способствует созданию такой системы, 
которую будет легко поддерживать и расширять в течение долгого времени. 
Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим 
программным обеспечением для его улучшения.
2. ####Для чего используется JavaDoc?
Наибольшая проблема, связанная с документированием кода – поддержка этой документации. 
Если документация и код разделены, возникают трудности, связанные с необходимостью внесения изменений 
в соответствующие разделы сопроводительной документации всякий раз при изменении программного кода. 
Среда разработки предлагает решение – связать код с документацией, поместив всё в один файл.
Javadoc — генератор документации в HTML-формате из комментариев исходного кода на Java.
3. ####Как писать JavaDoc?
JavaDoc - это генератор документации в HTML-формате из комментариев исходного кода Java. 
Для создания элементов, которые позволят программисту анализировать структуру приложения, 
JavaDoc предоставляет API. При этом комментарий должен находиться перед документируемым элементом.
писать  --> /** комментирование документации */

4. ####Что такое Java code convention? ==  Соглашения по оформлению кода Java
Соглашения по оформлению кода имеют важное значение для программистов по нескольким причинам:
* 80% от стоимости программного обеспечения приходится на его обслуживание.
* Вряд ли какое-либо программное обеспечение поддерживается в течение всей своей жизни одним автором.
* Соглашения по оформлению кода улучшают читабельность программы, позволяя разработчикам намного быстрее и тщательнее понять новый код.
* Если вы предоставляете свой исходный код как готовую программу, вы должны его хорошо запаковать и очистить, как и остальные программы, которые создаёте
  JetBrains IntelliJ IDEA	Ctrl + Alt + L

5. ####Расскажите про принципы составления Java класса.



SOLID принципы советуют, как проектировать модули, 
т.е. кирпичики, из которых строится приложение. Цель принципов — проектировать модули, которые:
+ способствуют изменениям
+ легко понимаемы
+ повторно используемы

+ [1. Принципы Kiss, Dry и Yagni](#1-Что-такое-KISS-DRY-YAGNI)
+ [2. Принципы TDD](#2-Что-такое-TDD)
+ [3. Принципы SRP](#3-Что-такое-SRP)
+ [4. Принципы OSP](#4-Что-такое-OSP)
+ [5. Принципы LSP](#5-Что-такое-LSP)
+ [6. Принципы ISP](#6-Что-такое-ISP)
+ [7. Принципы ISP](#6-Что-такое-DIP)





## 1 Что такое KISS DRY YAGNI

+ KISS - keep it simple and short  
       будь проще и краток
+ DRY - dont repeat yourself        
       не повторяйся
       То есть, старайтесь использовать уже существующие методы,
        чтобы решить новую задачу. Не копируйте код.
+ YAGNI - you arent going need it  
     тебе это не понадобится
     Подумайте, стоит ли создавать новый метод. 
     Можно ли решить задачу уже существующими методами.

[к оглавлению](#OOD)

## 2 Что такое TDD

Test Driven Development - «разработка через тестирование»
Модульное тестирование или юнит-тестирование (unit testing) — процесс в программировании, позволяющий проверить на корректность
 отдельные модули исходного кода программы. Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода.
Регрессоинное тестирование (regression testing) — обобщённое название для всех видов тестирования программного обеспечения
, направленных на обнаружение ошибок в уже протестированных участках исходного кода. Такие ошибки — когда после внесения изменений в программу перестаёт работать то, что должно было продолжать работать, — называют регрессионными ошибками.
Основная идея модульного тестирования заключается в том, чтобы написать тесты, в которых проверена наименьшая «единица» кода.
Любой тест, модульный он или нет, должен включать в себя некую проверку — мы называем её сверкой фактического результата с ожидаемым.
 Именно эта сверка и определяет, проходит тест или терпит неудачу.
 Тест, который всегда проходит, бесполезен.
 
 Тест, который всегда терпит неудачу, бесполезен.
 
 две основных причины для проведения модульного тестирования.
 
 Первая — улучшить дизайн кода.
 
 Вторая основная цель модульного тестирования — создать автоматизированный набор регрессионных тестов,
 который может работать как спецификация поведения программного обеспечения на низком уровне.

TDD — это, по сути, практика написания точных спецификаций, которые могут быть автоматически проверены до написания кода. 
 алгоритм TDD:
Создали тест.
Написали код под этот тест.
Зарефакторили код.

[к оглавлению](#OOD)
         
[read id](##https://medium.com/webbdev/solid-4ffc018077da)

## 3 Что такое SRP

Single Responsibility Principle and SOLID design - 
Принцип единственной ответственности
никогда не должно быть больше одной причины изменить класс
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности.

Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за что класс отвечает, а за что — нет. 
То есть можно будет вносить изменения и не бояться последствий — влияния на другие объекты. 
А еще подобный код гораздо проще тестировать, ведь вы покрываете тестами одну функциональность в изоляции от всех остальных.

[к оглавлению](#OOD)


## 4 Что такое OSP

Open-Closed Principle (Принцип открытости-закрытости)
Этот принцип емко описывают так: программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
Например, наше приложение должно отправлять уведомления. Используя dependency inversion, наш модуль объявляет только интерфейс отправки уведомлений, но не реализацию. Таким образом, логика нашего приложения содержится в одном dll файле, а класс отправки уведомлений, реализующий интерфейс — в другом. Таким образом, мы можем без изменения (перекомпиляции) модуля с логикой использовать различные способы отправки уведомлений.

[к оглавлению](#OOD)

## 5 Что такое LSP

прим. бабушке Liskov сейчас(15.03.2020) 80 лет и она проф МIT

The Liskov Substitution Principle  -- Принцип подстановки Барбары Лисков
Наследующий класс должен дополнять, а не замещать поведение базового класса.
#Что это значит на практике?
Если у нас есть класс A (не виртуальный, а вполне реально используемый в коде) и отнаследованный от него класс B, то если мы заменим все использования класса A на B, ничего не должно измениться в работе программы. Ведь класс B всего лишь расширяет функционал класса A. Если эта проверка работает, то поздравляю

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

[к оглавлению](#OOD)

## 6 Что такое ISP

The Interface Segregation Principle --- Принцип разделения интерфейса
клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.

Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

[к оглавлению](#OOD)

##6 Что такое DIP

The Dependency Inversion Principle --- Принцип инверсии зависимостей

Объектом зависимости должна быть абстракция, а не что-то конкретное.
#зависимости внутри системы строятся на основе абстракций.
+ 1. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
+ 2. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.

[к оглавлению](#OOD)
